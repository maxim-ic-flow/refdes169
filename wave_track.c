#include "global.h"
#include "wave_track.h"
#include "max3510x_regs.h"

#define WAVE_TRACK_SAMPLE_WAVE	(WAVE_TRACK_HIT_COUNTS>>1)  // must be > 1 && < WAVE_TRACK_HIT_COUNTS

int8_t wave_track_phase( max3510x_time_t ref, max3510x_time_t sample, max3510x_time_t period )
{
	// detects large phase shifts in TOF due to mis-identification of the T1 wave (comparator threshold set wrong for the signal received).
	// this occurs when rapid amplitude changes occur which exceed the capability of the amplitude tracking algorithm

	// 'ref' is a TOF value believed to be correct (defined as being within +/- 1/2 transducer oscillation period of expected)
	// 'sample' is a new TOF value to be evaluated for phase shifts beyond +/- 1/2 transducer oscillation period.
	// 'half_period' is one half the transducer oscillation period

	// 'result' is an measurement of the number of waves 'sample' has shifted from 'ref'.  positive shifts are earlier in time.

    max3510x_time_t delta = ref-sample;
    max3510x_time_t abs_delta = delta > 0 ? delta : -delta;
	int32_t result = ( 2*(abs_delta)+period ) / ( 2*period );
	return delta > 0 ? result : -result;
}


float_t wave_track_linearize_ratio( uint8_t ratio )
{
	// establishes a linear reciprocal relation between t1/t2 ratio and comparator threshold
	// based on the assumption that the t1 wave is sinusoidal and the t2 wave is ideal.
	// reciprocal is used simply to avoid a division.
	// 
	// thresh = 1/cos( pi/2 * ratio )
	// 
	// ratio is clamped to a realistic range, but should never clamp unless something is wrong with the TDC
	// configuration or flowbody hardware.  Loss of amplitude tracking is likely when clampling occurs, but
	// other more serious problems will exist in this case.
	// 

	static const float_t ratio2thresh[52] =
	{
		// this table is generated by the matlab script 'calc_linearize_ratio.m'
		1.233871e+00, 1.245008e+00, 1.256539e+00, 1.268478e+00, 1.280841e+00, 1.293644e+00, 1.306904e+00, 1.320640e+00, 1.334870e+00, 
		1.349617e+00, 1.364900e+00, 1.380744e+00, 1.397173e+00, 1.414214e+00, 1.431893e+00, 1.450241e+00, 1.469290e+00, 1.489073e+00, 
		1.509626e+00, 1.530988e+00, 1.553201e+00, 1.576309e+00, 1.600360e+00, 1.625404e+00, 1.651498e+00, 1.678699e+00, 1.707074e+00, 
		1.736689e+00, 1.767622e+00, 1.799952e+00, 1.833769e+00, 1.869167e+00, 1.906252e+00, 1.945136e+00, 1.985946e+00, 2.028817e+00, 
		2.073898e+00, 2.121355e+00, 2.171370e+00, 2.224143e+00, 2.279897e+00, 2.338880e+00, 2.401367e+00, 2.467665e+00, 2.538122e+00, 
		2.613126e+00, 2.693115e+00, 2.778588e+00, 2.870110e+00, 2.968329e+00, 3.073988e+00, 3.187945e+00
/*
		8.104572e-01, 8.032075e-01, 7.958369e-01, 7.883464e-01, 7.807372e-01, 7.730105e-01, 7.651673e-01, 7.572088e-01, 
		7.491364e-01, 7.409511e-01, 7.326543e-01, 7.242471e-01, 7.157308e-01, 7.071068e-01, 6.983762e-01, 6.895405e-01, 
		6.806010e-01, 6.715590e-01, 6.624158e-01, 6.531728e-01, 6.438315e-01, 6.343933e-01, 6.248595e-01, 6.152316e-01, 
		6.055110e-01, 5.956993e-01, 5.857979e-01, 5.758082e-01, 5.657318e-01, 5.555702e-01, 5.453250e-01, 5.349976e-01, 
		5.245897e-01, 5.141027e-01, 5.035384e-01, 4.928982e-01, 4.821838e-01, 4.713967e-01, 4.605387e-01, 4.496113e-01, 
		4.386162e-01, 4.275551e-01, 4.164296e-01, 4.052413e-01, 3.939920e-01, 3.826834e-01, 3.713172e-01, 3.598950e-01, 
		3.484187e-01, 3.368899e-01, 3.253103e-01, 3.136817e-01
*/
	};
	if( ratio < 52 )
		ratio = 52;
	else if( ratio > 103 )
		ratio = 103;
	return ratio2thresh[ratio-52];
}

uint8_t wave_track_amplitude( uint8_t offset, uint8_t t1_t2, float_t target )
{
	// returns suggested comparator offset given the last measured t1/t2 ratio and a target offset position relative to the t1 wave peak
	// enables tracking slow-moving (relative to sampling frequency) amplitude changes due to things like temperature changes or gas composition changes.

	// Tracking can be lost if the amplitude changes rapidly.  Use the phase tracking algorithm to detect these events.

	const float_t max = (float_t)MAX3510X_REG_TOF_C_OFFSETR_MAX;

	float_t ratio = wave_track_linearize_ratio( t1_t2 );
	float_t last = offset;

	float_t new_offset = last * target * ratio;  // ideal offset has a ratiometric relation to the current offset and the wave-peak relative target offset 
	if( new_offset > max )
	{
		new_offset = max;
	}
	return roundf(new_offset);
}

max3510x_time_t wave_track_process_sample( max3510x_time_t *p_tof, const max3510x_fixed_t *p_hits )
{

    uint8_t i;
    max3510x_time_t sum ;
    max3510x_time_t h1, h2;
    max3510x_time_t diff = 0;

    *p_tof = sum = h1 = max3510x_fixed_to_time( p_hits );

    for(i=1;i<WAVE_TRACK_HIT_COUNTS;i++)
    {
        p_tof[i] = h2 = max3510x_fixed_to_time( &p_hits[i] );
        sum += h2;
        diff += h2 - h1;
        h1 = h2;
    }
	return diff / (WAVE_TRACK_HIT_COUNTS-1);
}


bool wave_track( wave_track_t * p_wt, const max3510x_fixed_t *p_hits, uint8_t t1_t2_ratio )
{
	// see wave_track_t definition for inputs/outputs
	// returns true if the waveform was sucessfully tracked

	p_wt->period = wave_track_process_sample( p_wt->hits, p_hits );
	max3510x_time_t tof = p_wt->hits[ WAVE_TRACK_SAMPLE_WAVE ];
	if( !p_wt->tof )
	{
		p_wt->tof = tof;
	}

	int8_t phase = wave_track_phase( p_wt->tof, tof, p_wt->period );
	if( phase )
	{
		uint8_t ndx = WAVE_TRACK_SAMPLE_WAVE + phase;
		if( ndx < WAVE_TRACK_HIT_COUNTS )
			tof = p_wt->hits[ ndx ];
		else
			tof = 0;
	}
	if( p_wt->amplitude_target )
		p_wt->comparator_offset = wave_track_amplitude( p_wt->comparator_offset, t1_t2_ratio,  p_wt->amplitude_target );
	p_wt->tof = tof;
	return tof ? true : false;
}

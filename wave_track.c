#include "global.h"
#include "wave_track.h"
#include "max3510x_regs.h"

#define WAVE_TRACK_SAMPLE_WAVE	(WAVE_TRACK_HIT_COUNTS>>1)  // must be > 1 && < WAVE_TRACK_HIT_COUNTS

int8_t wave_track_phase( max3510x_time_t ref, max3510x_time_t sample, max3510x_time_t period )
{
	// detects large phase shifts in TOF due to mis-identification of the T1 wave (comparator threshold set wrong for the signal received).
	// this occurs when rapid amplitude changes occur which exceed the capability of the amplitude tracking algorithm

	// 'ref' is a TOF value believed to be correct (defined as being within +/- 1/2 transducer oscillation period of expected)
	// 'sample' is a new TOF value to be evaluated for phase shifts beyond +/- 1/2 transducer oscillation period.
	// 'half_period' is one half the transducer oscillation period

	// 'result' is an measurement of the number of waves 'sample' has shifted from 'ref'.  positive shifts are earlier in time.

    max3510x_time_t delta = ref-sample;
    max3510x_time_t abs_delta = delta > 0 ? delta : -delta;
	int32_t result = ( 2*(abs_delta)+period ) / ( 2*period );
	return delta > 0 ? result : -result;
}


uint16_t wave_track_linearize_ratio( uint8_t ratio )
{
	// establishes a linear reciprocal relation between t1/t2 ratio and comparator threshold
	// based on the assumption that the t1 wave is sinusoidal and the t2 wave is ideal.
	// reciprocal is used simply to avoid a division.
	// 
	// thresh = 1/cos( pi/2 * ratio )
	// 
	// ratio is clamped to a realistic range, but should never clamp unless something is wrong with the TDC
	// configuration or flowbody hardware.  Loss of amplitude tracking is likely when clampling occurs, but
	// other more serious problems will exist in this case.
	// 
	// these tables were generated by the matlab script 'calc_linearize_ratio.m'

/*
	static const float_t ratio2thresh[52] =
	{
		1.233871e+00, 1.245008e+00, 1.256539e+00, 1.268478e+00, 1.280841e+00, 1.293644e+00, 1.306904e+00, 1.320640e+00, 1.334870e+00, 
		1.349617e+00, 1.364900e+00, 1.380744e+00, 1.397173e+00, 1.414214e+00, 1.431893e+00, 1.450241e+00, 1.469290e+00, 1.489073e+00, 
		1.509626e+00, 1.530988e+00, 1.553201e+00, 1.576309e+00, 1.600360e+00, 1.625404e+00, 1.651498e+00, 1.678699e+00, 1.707074e+00, 
		1.736689e+00, 1.767622e+00, 1.799952e+00, 1.833769e+00, 1.869167e+00, 1.906252e+00, 1.945136e+00, 1.985946e+00, 2.028817e+00, 
		2.073898e+00, 2.121355e+00, 2.171370e+00, 2.224143e+00, 2.279897e+00, 2.338880e+00, 2.401367e+00, 2.467665e+00, 2.538122e+00, 
		2.613126e+00, 2.693115e+00, 2.778588e+00, 2.870110e+00, 2.968329e+00, 3.073988e+00, 3.187945e+00
	};
*/
	static const uint16_t ratio2thresh[52] =
	{
        20216, 20398, 20587, 20783, 20985, 21195, 21412, 21637, 21871, 22112, 22363, 22622, 22891,
        23170, 23460, 23761, 24073, 24397, 24734, 25084, 25448, 25826, 26220, 26631, 27058, 27504, 
        27969, 28454, 28961, 29490, 30044, 30624, 31232, 31869, 32538, 33240, 33979, 34756, 35576, 
        36440, 37354, 38320, 39344, 40430, 41585, 42813, 44124, 45524, 47024, 48633, 50364, 52231
	};

	if( ratio < 52 )
		ratio = 52;
	else if( ratio > 103 )
		ratio = 103;
	return ratio2thresh[ratio-52]; // fixed point result is scaled by 1/4
}

uint8_t wave_track_amplitude( uint8_t offset, uint8_t t1_t2, uint16_t q16_target )
{
	// returns suggested comparator offset given the last measured t1/t2 ratio and a target offset position relative to the t1 wave peak
	// enables tracking slow-moving (relative to sampling frequency) amplitude changes due to things like temperature changes or gas composition changes.

	// Tracking can be lost if the amplitude changes rapidly.  Use the phase tracking algorithm to detect these events.

	const uint8_t max = MAX3510X_REG_TOF_C_OFFSETR_MAX;

	uint16_t ratio = wave_track_linearize_ratio( t1_t2 ); // ratio is scaled by 2^-2

	uint16_t offset_scaled = offset << 9; // scaled 2^8

	// ideal offset has a ratiometric relation to the current offset and the wave-peak relative target offset 

	uint32_t p1 = (uint32_t)offset_scaled * q16_target;
	uint32_t p2 = (uint32_t)(p1 >> 16) * ratio;  
    uint32_t p3 = p2 + (1<<(5+16));      // offset to facilitate rounding when unscaled
    uint8_t new_offset = p3 >> (16+9-2); // unscaling here
	if( new_offset > max )
		new_offset = max;
	return new_offset;
}

max3510x_time_t wave_track_process_sample( max3510x_time_t *p_tof, const max3510x_fixed_t *p_hits )
{

    uint8_t i;
    max3510x_time_t sum ;
    max3510x_time_t h1, h2;
    max3510x_time_t diff = 0;

    *p_tof = sum = h1 = max3510x_fixed_to_time( p_hits );

    for(i=1;i<WAVE_TRACK_HIT_COUNTS;i++)
    {
        p_tof[i] = h2 = max3510x_fixed_to_time( &p_hits[i] );
        sum += h2;
        diff += h2 - h1;
        h1 = h2;
    }
	return diff / (WAVE_TRACK_HIT_COUNTS-1);
}


bool wave_track( wave_track_t * p_wt, const max3510x_fixed_t *p_hits, uint8_t t1_t2_ratio )
{
	// see wave_track_t definition for inputs/outputs
	// returns true if the waveform was sucessfully tracked

	p_wt->period = wave_track_process_sample( p_wt->hits, p_hits );
	max3510x_time_t tof = p_wt->hits[ WAVE_TRACK_SAMPLE_WAVE ];
	if( !p_wt->tof )
	{
		p_wt->tof = tof;
	}

	int8_t phase = wave_track_phase( p_wt->tof, tof, p_wt->period );
	if( phase )
	{
		uint8_t ndx = WAVE_TRACK_SAMPLE_WAVE + phase;
		if( ndx < WAVE_TRACK_HIT_COUNTS )
			tof = p_wt->hits[ ndx ];
		else
			tof = 0;
	}
	if( p_wt->amplitude_target )
		p_wt->comparator_offset = wave_track_amplitude( p_wt->comparator_offset, t1_t2_ratio,  p_wt->amplitude_target );
	p_wt->tof = tof;
	return tof ? true : false;
}

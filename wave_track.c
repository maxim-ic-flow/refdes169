/*******************************************************************************
 * Copyright (C) 2018 Maxim Integrated Products, Inc., All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL MAXIM INTEGRATED BE LIABLE FOR ANY CLAIM, DAMAGES
 * OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 *
 * Except as contained in this notice, the name of Maxim Integrated
 * Products, Inc. shall not be used except as stated in the Maxim Integrated
 * Products, Inc. Branding Policy.
 *
 * The mere transfer of this software does not imply any licenses
 * of trade secrets, proprietary technology, copyrights, patents,
 * trademarks, maskwork rights, or any other form of intellectual
 * property whatsoever. Maxim Integrated Products, Inc. retains all
 * ownership rights.
 *
 ******************************************************************************/

#include "global.h"
#include "wave_track.h"
#include "max3510x_regs.h"

#define WAVE_TRACK_SAMPLE_WAVE	(WAVE_TRACK_HIT_COUNTS>>1)  // must be > 1 && < WAVE_TRACK_HIT_COUNTS

int8_t wave_track_phase( max3510x_time_t ref, max3510x_time_t sample, max3510x_time_t period )
{
	// Detects large phase shifts in TOF due to changes T1 wave identification.
	// This occurs when rapid amplitude changes occur which exceed the capability of the amplitude tracking algorithm (if enabled)

	// 'ref' is a TOF value believed to be correct (defined as being within +/- 1/2 transducer oscillation period of expected)
	// 'sample' is a new TOF value to be evaluated for phase shifts beyond +/- 1/2 transducer oscillation period.
	// 'half_period' is one half the transducer oscillation period

	// 'result' is an measurement of the number of waves 'sample' has shifted from 'ref'.  positive shifts are earlier in time.

    max3510x_time_t delta = ref-sample;
    max3510x_time_t abs_delta = delta > 0 ? delta : -delta;
	int32_t result = ( 2*(abs_delta)+period ) / ( 2*period );
	return delta > 0 ? result : -result;
}


uint16_t wave_track_linearize_ratio( uint8_t ratio )
{
	// Establishes a linear reciprocal relation between t1/t2 ratio and comparator offset
	// based on the assumption that the t1 wave is sinusoidal and the t2 wave is ideal.
	// 
	// These assumptions are true enough in practice for this method to be useful, but be aware
	// that amplutide and frequency differences between t1 and t2 will cause errors that can be 
	// significant in some flowbody/transducer designs.
	// 
	// Reciprocal is used simply to avoid a division.
	// 
	// comparator offset = 1/cos( pi/2 * ratio )
	// 
	// Ratio is clamped to a realistic range, but should never clamp unless something is wrong with the TDC
	// configuration or flowbody hardware.  Loss of amplitude tracking is likely when clampling occurs, but
	// other more serious system problems will likely exist in this case. 
	// 

	static const uint16_t ratio2offset[95] =
	{
		// This Q16 fixed-point table was generated by the matlab script 'calc_linearize_ratio.m'
        16595, 16629, 16666, 16705, 16747, 16792, 16840, 16890, 16944, 17000, 17059, 17121, 17187, 17255, 
        17326, 17401, 17479, 17561, 17646, 17734, 17826, 17921, 18021, 18124, 18231, 18343, 18458, 18578, 
        18702, 18830, 18964, 19102, 19245, 19393, 19546, 19705, 19869, 20040, 20216, 20398, 20587, 20783, 
        20985, 21195, 21412, 21637, 21871, 22112, 22363, 22622, 22891, 23170, 23460, 23761, 24073, 24397, 
        24734, 25084, 25448, 25826, 26220, 26631, 27058, 27504, 27969, 28454, 28961, 29490, 30044, 30624, 
        31232, 31869, 32538, 33240, 33979, 34756, 35576, 36440, 37354, 38320, 39344, 40430, 41585, 42813, 
        44124, 45524, 47024, 48633, 50364, 52231, 54251, 56441, 58825, 61429, 64285
	};

	if( ratio < 14 )
		ratio = 14;
	else if( ratio > 116 )
		ratio = 116;
	return ratio2offset[ratio-14]; // Q16 result is scaled by 2^-2
}

uint8_t wave_track_amplitude( uint8_t offset, uint8_t t1_t2, uint16_t q16_target )
{
	// Returns suggested comparator offset given the last measured t1/t2 ratio and a target offset position relative to the t1 wave peak.
	// Enables tracking slow-moving (relative to sampling frequency) amplitude changes due to things like temperature changes or gas composition changes.
	// Tracking can be lost if the amplitude changes rapidly or exceeds the range of the comparator.  Amplitude tracking automatically resumes on a 
	// new wave and the phase tracking algorithm handles the wave descrepancy.  The effectiveness of this algorithm is proportional to sampling frequency.

	const uint8_t max = MAX3510X_REG_TOF_C_OFFSETR_MAX;

	uint16_t ratio = wave_track_linearize_ratio( t1_t2 ); // ratio is scaled by 2^-2

	uint16_t offset_scaled = offset << 9; // scaled 2^9

	// ideal offset has a ratiometric relation to the current offset and the wave-peak relative target offset 

	uint32_t p1 = (uint32_t)offset_scaled * q16_target;
	uint32_t p2 = (uint32_t)(p1 >> 16) * ratio;  
    uint32_t p3 = p2 + (1<<(5+16));      // offset to facilitate rounding when unscaled
    uint8_t new_offset = p3 >> (16+9-2); // unscaling here
	if( new_offset > max )
		new_offset = max;
	return new_offset;
}

max3510x_time_t wave_track_process_sample( max3510x_time_t *p_tof, const max3510x_fixed_t *p_hits )
{
	// transforms TDC-specific formats to a 32-bit unsigned format
	// also calculates oscillation period to facilitate transducer temperature compensation
    uint8_t i;
    max3510x_time_t sum ;
    max3510x_time_t h1, h2;
    max3510x_time_t diff = 0;

    *p_tof = sum = h1 = max3510x_fixed_to_time( p_hits );

    for(i=1;i<WAVE_TRACK_HIT_COUNTS;i++)
    {
        p_tof[i] = h2 = max3510x_fixed_to_time( &p_hits[i] );
        sum += h2;
        diff += h2 - h1;
        h1 = h2;
    }
	return diff / (WAVE_TRACK_HIT_COUNTS-1);  // division not strictly necessary, but helps with debugging to keep this value unscaled.
}


bool wave_track_direction( wave_track_direction_t * p_dir, const max3510x_fixed_t *p_hits, uint8_t t1_t2_ratio )
{
	// Top-level wave-tracking API to impliment phase tracking and optionally amplitude tracking.
	// 
	// see wave_track_t definition for inputs/outputs
	// 
	// returns true if the waveform was successfully tracked
	// 
	// Each measurement direction (up and down) is tracked independantly so this function
	// should be called twice, once for each direction.
	//

	p_dir->period = wave_track_process_sample( p_dir->hits, p_hits );
	max3510x_time_t tof = p_dir->hits[ WAVE_TRACK_SAMPLE_WAVE + p_dir->phase ] ;
	if( !p_dir->tof )
	{
		p_dir->tof = tof;
	}

	int8_t phase = wave_track_phase( p_dir->tof, tof, p_dir->period );
	if( phase )
	{
		// Phase tracking identifies which of the (up to) 6 hit waves is contains a TOF value that corresponds to the previously measured TOF.  
		// This algorithm is limited by the number of available hit registers. Wave shifts that exceed this capacity will cause loss of phase 
		// tracking and with it the ability to discern TOF until the system returns to range. 
		// 
		// This algorithm works well to track signals that change slowly over time relative to sampling frequency.
		// 
		// This algorithm assumes that the first waveform presented is prototypical.  It must be a waveform that can be unambiguously referenced
		// to a set of known application-specific operating conditions.
		//
		// Tracking failures can be reset by p_wt->tof = 0 and presenting a known good waveform.

		uint8_t ndx = WAVE_TRACK_SAMPLE_WAVE + phase + p_dir->phase;
		if( ndx < WAVE_TRACK_HIT_COUNTS )
		{
			tof = p_dir->hits[ ndx ];
		}
		else
			tof = 0;	// Indicates loss of phase tracking.  No valid TOF measurements available.  
						// Application-specific logic should be added to handle this case.
	}
	if( p_dir->ratio_tracking )  // if ratio_tracking is zero, then amplitude tracking is disabled.
	{
		uint8_t offset = wave_track_amplitude( p_dir->comparator_offset, t1_t2_ratio,  p_dir->ratio_tracking );
		if(  offset < p_dir->mimimum_offset )
			offset = p_dir->mimimum_offset;
		p_dir->comparator_offset = offset;
	}
    p_dir->tof = tof;
	return tof ? true : false;
}

bool wave_track_converge( wave_track_direction_t * p_up, wave_track_direction_t * p_down )
{
	bool success = true;
	const uint8_t weight[WAVE_TRACK_HIT_COUNTS] = { 0, 1, 3, 2, 1, 0 };

	uint8_t i, j, min_i, min_j;

	max3510x_time_t period = (p_up->period + p_down->period )/2;
 	if( wave_track_phase( p_up->tof, p_down->tof, period ) )
	{
		int8_t min_delta = WAVE_TRACK_HIT_COUNTS;

		for(i=0;i<WAVE_TRACK_HIT_COUNTS;i++)
		{
			for(j=0;j<WAVE_TRACK_HIT_COUNTS;j++)
			{
				int8_t delta = wave_track_phase( p_up->hits[i], p_down->hits[j], period );
				delta = delta < 0 ? -delta : delta;
				if( delta == min_delta )
				{
					// give preference to waves in the middle of hit wave array
					if( (weight[i] + weight[j]) > (weight[min_i] + weight[min_j]) )
					{
						min_i = i;
						min_j = j;
						min_delta = delta;
					}
				}
				else if( delta < min_delta )
				{
					min_delta = delta;
					min_i = i;
					min_j = j;
				}
				
			}
		}
		// adjust directional phase
		p_up->phase = WAVE_TRACK_SAMPLE_WAVE - min_i;
		p_down->phase = WAVE_TRACK_SAMPLE_WAVE - min_j;
		if( success = (wave_track_phase( p_up->hits[min_i], p_down->hits[min_j], period )==0) )
		{
			p_up->tof = p_up->hits[min_i];
			p_down->tof =  p_down->hits[min_j];
		}
	}
	return success;
}

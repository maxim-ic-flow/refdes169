#include "global.h"
#include "wave_track.h"
#include "max3510x_regs.h"

#define WAVE_TRACK_SAMPLE_WAVE	(WAVE_TRACK_HIT_COUNTS>>1)  // must be > 1 && < WAVE_TRACK_HIT_COUNTS
#define WAVE_TRACK_MINIMUM	20	// adjust according to system noise floor

int8_t wave_track_phase( max3510x_time_t ref, max3510x_time_t sample, max3510x_time_t period )
{
	// Detects large phase shifts in TOF due to changes T1 wave identification.
	// This occurs when rapid amplitude changes occur which exceed the capability of the amplitude tracking algorithm (if enabled)

	// 'ref' is a TOF value believed to be correct (defined as being within +/- 1/2 transducer oscillation period of expected)
	// 'sample' is a new TOF value to be evaluated for phase shifts beyond +/- 1/2 transducer oscillation period.
	// 'half_period' is one half the transducer oscillation period

	// 'result' is an measurement of the number of waves 'sample' has shifted from 'ref'.  positive shifts are earlier in time.

    max3510x_time_t delta = ref-sample;
    max3510x_time_t abs_delta = delta > 0 ? delta : -delta;
	int32_t result = ( 2*(abs_delta)+period ) / ( 2*period );
	return delta > 0 ? result : -result;
}


uint16_t wave_track_linearize_ratio( uint8_t ratio )
{
	// Establishes a linear reciprocal relation between t1/t2 ratio and comparator offset
	// based on the assumption that the t1 wave is sinusoidal and the t2 wave is ideal.
	// 
	// These assumptions are true enough in practice for this method to be useful, but be aware
	// that amplutide and frequency differences between t1 and t2 will cause errors that can be 
	// significant in some flowbody/transducer designs.
	// 
	// Reciprocal is used simply to avoid a division.
	// 
	// comparator offset = 1/cos( pi/2 * ratio )
	// 
	// Ratio is clamped to a realistic range, but should never clamp unless something is wrong with the TDC
	// configuration or flowbody hardware.  Loss of amplitude tracking is likely when clampling occurs, but
	// other more serious system problems will exist in this case. 
	// 

	static const uint16_t ratio2offset[52] =
	{
		// This Q16 fixed-point table was generated by the matlab script 'calc_linearize_ratio.m'
        20216, 20398, 20587, 20783, 20985, 21195, 21412, 21637, 21871, 22112, 22363, 22622, 22891,
        23170, 23460, 23761, 24073, 24397, 24734, 25084, 25448, 25826, 26220, 26631, 27058, 27504, 
        27969, 28454, 28961, 29490, 30044, 30624, 31232, 31869, 32538, 33240, 33979, 34756, 35576, 
        36440, 37354, 38320, 39344, 40430, 41585, 42813, 44124, 45524, 47024, 48633, 50364, 52231
	};

	if( ratio < 52 )
		ratio = 52;
	else if( ratio > 103 )
		ratio = 103;
	return ratio2offset[ratio-52]; // Q16 result is scaled by 2^-2
}

uint8_t wave_track_amplitude( uint8_t offset, uint8_t t1_t2, uint16_t q16_target )
{
	// Returns suggested comparator offset given the last measured t1/t2 ratio and a target offset position relative to the t1 wave peak.
	// Enables tracking slow-moving (relative to sampling frequency) amplitude changes due to things like temperature changes or gas composition changes.
	// Tracking can be lost if the amplitude changes rapidly or exceeds the range of the comparator.  Amplitude tracking automatically resumes on a 
	// new wave and the phase tracking algorithm handles the wave descrepancy.  The effectiveness of this algorithm is proportional to sampling frequency.

	const uint8_t max = MAX3510X_REG_TOF_C_OFFSETR_MAX;

	uint16_t ratio = wave_track_linearize_ratio( t1_t2 ); // ratio is scaled by 2^-2

	uint16_t offset_scaled = offset << 9; // scaled 2^9

	// ideal offset has a ratiometric relation to the current offset and the wave-peak relative target offset 

	uint32_t p1 = (uint32_t)offset_scaled * q16_target;
	uint32_t p2 = (uint32_t)(p1 >> 16) * ratio;  
    uint32_t p3 = p2 + (1<<(5+16));      // offset to facilitate rounding when unscaled
    uint8_t new_offset = p3 >> (16+9-2); // unscaling here
	if( new_offset > max )
		new_offset = max;
	if( new_offset < WAVE_TRACK_MINIMUM )	// minimum prevents amplitude tracking below the system noise floor
		new_offset = WAVE_TRACK_MINIMUM;	// this includes transducer "ring-down" noise that may be present in some systems
	return new_offset;
}

max3510x_time_t wave_track_process_sample( max3510x_time_t *p_tof, const max3510x_fixed_t *p_hits )
{
	// transforms TDC-specific formats to a 32-bit unsigned format
	// also calculates oscillation period to facilitate transducer temperature compensation
    uint8_t i;
    max3510x_time_t sum ;
    max3510x_time_t h1, h2;
    max3510x_time_t diff = 0;

    *p_tof = sum = h1 = max3510x_fixed_to_time( p_hits );

    for(i=1;i<WAVE_TRACK_HIT_COUNTS;i++)
    {
        p_tof[i] = h2 = max3510x_fixed_to_time( &p_hits[i] );
        sum += h2;
        diff += h2 - h1;
        h1 = h2;
    }
	return diff / (WAVE_TRACK_HIT_COUNTS-1);  // division not strictly necessary, but helps with debugging to keep this value unscaled.
}


bool wave_track_direction( wave_track_direction_t * p_dir, const max3510x_fixed_t *p_hits, uint8_t t1_t2_ratio )
{
	// Top-level wave-tracking API to impliment phase tracking and optionally amplitude tracking.
	// 
	// see wave_track_t definition for inputs/outputs
	// 
	// returns true if the waveform was successfully tracked
	// 
	// Each measurement direction (up and down) is tracked independantly so this function
	// should be called twice, once for each direction.
	//

	p_dir->period = wave_track_process_sample( p_dir->hits, p_hits );
	max3510x_time_t tof = p_dir->hits[ WAVE_TRACK_SAMPLE_WAVE + p_dir->phase ] ;
	if( !p_dir->tof )
	{
		p_dir->tof = tof;
	}

	int8_t phase = wave_track_phase( p_dir->tof, tof, p_dir->period );
	if( phase )
	{
		// Phase tracking identifies which of the (up to) 6 hit waves is contains a TOF value that corosponds to the previously measured TOF.  
		// This algorithm is limited by the number of available hit registers. Wave shifts that exceed this capacity will cause loss of phase 
		// tracking and with it the ability to discern TOF until the system returns to range. 
		// 
		// This algorithm works well to track signals that change slowly over time relative to sampling frequency.
		// 
		// This algorithm assumes that the first waveform presented is prototypical.  It must be a waveform that can be unambiguously referenced
		// to a set of known application-specfic operating conditions.
		//
		// Tracking failures can be reset by p_wt->tof = 0 and presenting a known good waveform.

		uint8_t ndx = WAVE_TRACK_SAMPLE_WAVE + phase + p_dir->phase;
		if( ndx < WAVE_TRACK_HIT_COUNTS )
		{
			tof = p_dir->hits[ ndx ];
		}
		else
			tof = 0;	// Indicates loss of phase tracking.  No valid TOF measurements available.  
						// Application-specific logic should be added to handle this case.
	}
	if( p_dir->ratio_tracking )  // if ratio_tracking is zero, then amplitude tracking is disabled.
	{
		uint8_t offset = wave_track_amplitude( p_dir->comparator_offset, t1_t2_ratio,  p_dir->ratio_tracking );
		if(  offset < p_dir->mimimum_offset )
			offset = p_dir->mimimum_offset;
		p_dir->comparator_offset = offset;
	}
    p_dir->tof = tof;
	return tof ? true : false;
}

bool wave_track_converge( wave_track_direction_t * p_up, wave_track_direction_t * p_down )
{
	bool success = true;
	const uint8_t weight[WAVE_TRACK_HIT_COUNTS] = { 0, 1, 3, 2, 1, 0 };

	uint8_t i, j, min_i, min_j;

	max3510x_time_t period = (p_up->period + p_down->period )/2;
 	if( wave_track_phase( p_up->tof, p_down->tof, period ) )
	{
		int8_t min_delta = WAVE_TRACK_HIT_COUNTS;

		for(i=0;i<WAVE_TRACK_HIT_COUNTS;i++)
		{
			for(j=0;j<WAVE_TRACK_HIT_COUNTS;j++)
			{
				int8_t delta = wave_track_phase( p_up->hits[i], p_down->hits[j], period );
				delta = delta < 0 ? -delta : delta;
				if( delta == min_delta )
				{
					// give preference to waves in the middle of hit wave array
					if( (weight[i] + weight[j]) > (weight[min_i] + weight[min_j]) )
					{
						min_i = i;
						min_j = j;
						min_delta = delta;
					}
				}
				else if( delta < min_delta )
				{
					min_delta = delta;
					min_i = i;
					min_j = j;
				}
				
			}
		}
		// adjust directional phase
		p_up->phase = WAVE_TRACK_SAMPLE_WAVE - min_i;
		p_down->phase = WAVE_TRACK_SAMPLE_WAVE - min_j;
		if( success = (wave_track_phase( p_up->hits[min_i], p_down->hits[min_j], period )==0) )
		{
			p_up->tof = p_up->hits[min_i];
			p_down->tof =  p_down->hits[min_j];
		}
	}
	return success;
}
